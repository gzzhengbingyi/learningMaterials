# 准备

## 基础知识

### 跨域

#### 1. 定义
同源策略规定不能加载协议或域名或端口不一致源的资源，而跨域刚好相反，就是要获取这些资源。

#### 2.实现

**[1]** 兄弟域名之间，设置`domain`为父域名，则可以共享 cookie 等资源

**[2]** iframe 跨域

a、onhashchange，父窗口以及 iframe 窗口通过监听hash的变化来传递信息。缺点：1. IE6、7不支持 onhashchange 2. hash 变化太快的话，有可能漏掉信息，因此要做一个100ms的延迟

b、window.name 通信，iframe 通过 window.name 设置通信数据，然后跳转到父窗口的域下页面，然后同域名通信。缺点：一次性使用

c、html5 新出的`window.postMessage`，根据`event.origin`来保证只对特定域名来源生效

**[3]** JSONP 通信，同源策略并不阻止js的获取，因此通过将回调函数名附带在链接后，服务端将数据塞到函数名内，返回的文件以js的形式解析

**[3]** CORS协议，通过白名单设置信赖来源（`Access-Control-Allow-Origin`）

**[4]** 服务器反向代理

**[5]** websocket 与服务器通信 

	

### 缓存

#### 1.缓存的形式
**[1]** `Expires`/`Cache-Control`，`Last-Modified`(`If-Modified-Since`)/`ETag`(`If-None-Match`)

**[2]** CDN 缓存以及 CDN Combo，CDN有对应的操作平台可以更新，或者对应的命令行更新，可以实现资源的推送以及清理缓存之类的操作

**[3]** `manifest`离线缓存，缺点：1. 更新的资源要二次刷新才能用 2.不支持增量更新，变化后资源全部重新下载 3.缺乏容错机制

**[4]** WindowStorage 缓存，不足就是存储的数据会变成字符串

**[5]** PWA 的`Service Worker`中`cacheStorage`（installing → installed → activating → activated），具体待实践

**[6]** IndexDB 缓存

### cookie

#### 1.不足
**[1]** 数量以及长度的限制
**[2]** 安全性问题，别人可以获取 cookie


### http协议

### 正则

### JS的一些特性（原型链、闭包等等）

### DOM

### 事件

### ajax

### 优化

### 安全（XSS、CSRF等）

### CSS应用

### 手写代码

### 项目经验

## 针对

### web动画

#### 1.形式

**[1]** gif/apng

**[2]** css3 animation

**[3]** canvas

**[4]** svg

**[5]** webgl

**[6]** 纯`js`动画，配合`requestAnimationFrame`使用

#### 2.js动画优化

**[1]** 避免频繁的 reflow

**[2]** 减少大面积的 paint

**[3]** 优化js性能，例如缓存一些耗性能操作的结果，例如合并操作，例如内存操作dom（documentFragment）

**[4]** 避免在动画过程中做高耗时操作，或者放在动画开头或者结尾处，又或者分摊到每一帧

**[5]** 高昂开销，尝试用 CSS3 的变换完成


### 响应式布局

### hybrid

#### 1. JSBridge 的原理及实现

**[1]** webview 调用 js，IOS：`stringByEvaluatingJavaScriptFromString()` , Android：`loadUrl()`

**[2]** js 调用 native，1、 url scheme（目前兼容性更加好）  2、webview 提供一个 api 接口（未来的趋势）

**[3]** url scheme 的缺点是连续多次修改 href，webview 只能接收到最后一次的，因此，可以采用 iframe 加载 url scheme 的形式

**[4]** url scheme 后面加上 eventName 以及处理过的 data（含 event ID）

### webview 性能优化

#### 1. webview 很慢的原因

**[1]** 初始化 webview 就花费了不少时间，后面的操作都被阻塞了。解决方案：1、客户端一开始就创建一个隐藏的 webview ，用的时候直接打开。缺点：a、占用内存 b、有可能会出现内存泄露； 2、在初始化的时候，native 代理请求资源，初始化好后直接从 native 获取资源

**[2]** DNS 时间消耗，建议 webview 资源域名与 native 资源域名一致

**[3]** HTTP 请求的 chunk 编码，`transfer-encoding: chunked`，优先输出一些确定的编码

**[4]** 防止关键渲染过程中的阻塞，如 CSS 阻塞了内联函数的解析，可以考虑交换两者位置，考虑避免 js 运行阻塞 html 的解析，将非首屏资源懒加载

**[5]** 手机的 CPU 提高不大，即使网络快了很多，js 的解析也会很慢，因此采取服务端渲染很重要，平常 ftl 就够了，缺点是组件不够独立，考虑同构。尽量避免重型框架，如简单的 zepto 够用的话，就用它好了。尽量统一框架，利用缓存。滑动区间尽量不要操作，touchmove 后再执行，如 sticky 的安卓实现

**[6]** 防止崩了，例如加载超过 2MB 的图片有可能会出现崩的情况

**[7]** 安全问题，如 CSP 的设置，已经 HTTPS 协议，以及改用 socket 请求

**[8]** 打开外链选择白名单机制，并提供一些明显的提示给用户 

### HTTP 以及 HTTPS 等网络协议

#### 1. HTTP 介绍

超文本传输协议，是从 Web 服务器传输文件到本地浏览器的通信协议，是 TCP/IP 协议组应用层的实现。

**request消息结构：**

**[1]** request line

**[2]** request header

**[3]** header 与 body 之间的空行

![cmd-markdown-logo](https://pic1.zhimg.com/80/v2-f718f80a2b288ca087d18b34b4120298_hd.jpg)


**response消息结构：**

**[1]** response line

**[2]** response header

**[3]** response 与 body 之间的空行

![cmd-markdown-logo](https://pic1.zhimg.com/80/v2-4af35fa7f749b86971181c472c151770_hd.jpg)

#### 2. HTTP 请求类型

**[1]** GET

**[2]** POST

**[3]** PUT，主体部分存储在服务器

**[4]** DELETE

**[5]** TRACE，对可能经过代理服务器传送的报文进行跟踪

**[6]** OPTIONS，决定可以在服务器上执行哪些方法

**[7]** HEADER，获取文档首部

**[8]** CONNECT，将请求转换到透明的 TCP/IP 通道

#### 3. GET 和 POST 的区别

**[1]** GET 的数据放在URL后面，通过 ？分割，POST 的数据放在 body 里面

**[2]** 因为浏览器限制，URL 有长度限制，而 POST 没有

**[3]** GET 的数据通过`Request.queryString`获取，POST 通过`Request.Form`获取

**[4]** GET 数据有安全性问题，可以从历史记录获取，或者变成书签

**[5]** GET 的数据可以缓存，而 POST 不行

**[6]** 编码类型可能不一样，GET 是`application/x-www-form-urlencoded` ，POST 除了这个外，还可能是`multipart/form-data`等

#### 4. HTTP 码

200，成功

204，成功但不返回

206，成功但返回一部分

301，永久重定向

302，临时重定向

303，临时重定向，要求是 get

304，不改变

307，临时重定向，要求 post

400，语法错误

401，未授权

403，拒绝服务

404，找不到资源

500，服务端错误

503，暂时响应不过来

#### 5. HTTP 版本区别以及 SPDY

**[1]** HTTP 1.1 和 HTTP 1.0 区别：

1、更多的缓存头 

2、引入range头，实现带宽优化，如返回资源某部分 

3、增加错误码 

4、HOST 头处理 

5、`Connection: keep-alive`长链接

**[2]** SPDY 和 HTTP 1.1 的区别

1、多路复用

2、压缩头部

3、请求优先级设置

4、服务端推送

5、开启 HTTPS

**[3]** SPDY 和 HTTP 2.0 的区别

1、HTTP 2.0 是明文传输

2、HTTP 2.0 消息头压缩算法和 SPDY 不一样

### 调试

#### 1. 调试的手段

**[1]** IOS 在 safari 设置里面开启调试，然后 USB 连接电脑，再在 PC safari 上打开真机调试； Android 在开发者选项中开启设置，然后 USB 连接电脑，在 PC chrome 上开启调试设置

**[2]** weinre，需要安装 nodejs，在移动端浏览器修改书签内容为 weinre 的代码后保存，访问调试页面后，点击书签

**[3]** 微信调试，使用微信提供的开发者工具有真机调试选项

### 安全

#### 1. 有哪些前端攻击

**[1]** XSS，运行恶意代码注入到页面上，使用户使用时受到影响

防御手段：

1、前后端对获取的数据来源进行特殊字符串转义

2、对存储的数据进行转义

3、开启 CSP 防止恶意代码加载其他资源

**[2]** CSRF 跨站脚本攻击，挟制用户在已登录页面进行非本意操作

防御手段：

1、防止长时间 session 不过期

2、增加 referer 字段检查

3、增加页面 token

4、敏感操作验证码

**[3]** SQL 注入，提交 SQL 到表达或者查询字段

防御手段：

1、转义特殊字符

2、不要动态拼装字符

**[4]** DDos 攻击，挟制用户进行合法或者非法访问页面

防御手段：

1、增加带宽

2、查封 IP

3、硬件防火墙

4、高性能设备

5、负载均衡

**[5]** SYN 虚拟 IP 占用服务器确认资源

防御手段：

1、缩短超时

2、增加最大半连接数

3、过滤网关保护

**[6]** HTTPS 劫持，中间人劫持 TCP/IP 请求，获取页面内容后，修改下次访问为 HTTP

防御手段：

1、HSTS，强制访问后就一直是HTTPS请求

2、后端 chunk 输出内容，增加修改页面难度

3、JavaScript 探针，发现页面不是 HTTPS 协议的话，清除缓存并跳转到安全链接

#### 2. CSP 介绍

附加的安全层，帮助检测和缓解某些类型的攻击，包括XSS和数据注入。

实现：

1、`Content-Security-Policy:`设置白名单